## 阿里一面

 + 自我介绍  名字  项目介绍等等
 + css 动画卡帧（了解图层概念） 怎么解决  在最短的时间内15.6ms中去渲染
    - 总结解决 CSS3 动画卡顿方案
          尽量使用 transform 当成动画熟悉，避免使用 height,width,margin,padding 等；

          要求较高时，可以开启浏览器开启 GPU 硬件加速。
    -  1.为什么会卡顿？
        * 有一个前提必须要提，前端开发者们都知道，浏览器是单线程运行的。
        * 但是我们要明确以下几个概念：单线程，主线程和合成线程。
        * 
        * 虽然说浏览器执行js是单线程执行（注意，是执行，并不是说浏览器只有1个线程，而是运行时，runing），但实际上浏览器的2个重要的执行线程，这 2 个线程协同工作来渲染一个网页：主线程和合成线程。
        * 
        * 一般情况下，主线程负责：运行 JavaScript；计算 HTML 元素的 CSS 样式；页面的布局；将元素绘制到一个或多个位图中；将这些位图交给合成线程。
    - 那么为什么会造成动画卡顿呢？
        * 原因就是主线程和合成线程的调度不合理。

        * 下面来详细说一下调度不合理的原因。
        * 
        * 在使用height，width，margin，padding作为transition的值时，会造成浏览器主线程的工作量较重，例如从margin-left：-20px渲染到margin-left:0，主线程需要计算样式margin-left:-19px,margin-left:-18px，一直到margin-left:0，而且每一次主线程  计算样式后，合成进程都需要绘制到GPU然后再渲染到屏幕上，前后总共进行20次主线程渲染，20次合成线程渲染，20+20次，总计40次计算。
        * 相应地，合成线程负责：通过 GPU 将位图绘制到屏幕上；通知主线程更新页面中可见或即将变成可见的部分的位图；计算出页面中哪部分是可见的；计算出当你在滚动页面时哪部分是即将变成可见的；当你滚动页面时将相应位置的元素移动到可视区域。
    - 在使用css3 transtion做动画效果时，transform实现的动画是与合成器线程相关的，不需要等待主线程样式计算或者 JS 执行，计算速度是很快的；而使用height，width，margin和padding时，导致布局和绘制的调整，主线程需要重新计算样式并且执行JS，计算速度自然就慢了。造成卡顿现象。
    - 2.使用GPU硬件加速
        * 平时我们写的css3动画（没有触发硬件加速的）都是使用浏览器缓慢的软件渲染引擎来执行，字面上意思就是没有开启硬件加速。比如有时候写的移动端网页的动画（比如最简单的模态框）在安卓手机上会出现卡帧的现象，有很大可能就是使用浏览器软件渲染引擎来执行，性能跟不上导致的。上面说到 硬件加速 就可以解决这个问题，性能跟不上嘛，那就Spider Man上（能力越大，责任越大）——来硬件加速，性能提上去呀（我知道这又是一个烂gag），其实所谓硬件加速就是告诉浏览器，让它使用GPU进行渲染，切换到GPU模式，发挥GPU的一系列功能。

        * 举个例子：
         CSS的  animations,  transforms 以及 transitions 不会自动开启GPU加速，而是由浏览器的缓慢的软件渲染引擎来执行。为了性能，这个时候或许你就需要开启硬件加速功能。那我们怎样才可以切换到GPU模式呢，很多浏览器提供了某些触发的CSS规则。
         Chrome, FireFox, Safari, IE9+和最新版本的Opera都支持硬件加速，当它们检测到页面中某个DOM元素应用了某些CSS规则时就会开启，最显著的特征的元素的3D变换。
        * 可能出现页面闪烁： （1） 隐藏   （2）前提：web-kit内核   transfrom:translate3d(0,0,0)
        * 使用3D硬件加速提升动画性能时，最好给元素增加一个z-index属性，人为干扰复合层的排序，可以有效减少chrome创建不必要的复合层，提升渲染性能，移动端优化效果尤为明显。
    - 3.图层的数量也有影响
 +  js基于单线程运行
    - 浏览器是多进程还是单进程?

    - 浏览器是多进程的，浏览器每一个 tab 标签都代表一个独立的进程（也不一定，因为多个空白 tab 标签会合并成一个进程），浏览器内核（浏览器渲染进程）属于浏览器多进程中的一种。

    - 浏览器每个进程有多个线程，主要有以下线程

        * 1）GUI 渲染线程:

        负责渲染页面，解析 HTML，CSS 构成 DOM 树等，当页面重绘或者由于某种操作引起回流都会调起该线程。和 JS 引擎线程是互斥的，当 JS 引擎线程在工作的时候，GUI 渲染线程会被挂起，GUI 更新被放入在 JS 任务队列中，等待 JS 引擎线程空闲的时候继续执行。

        * 2）JS 引擎线程:

           单线程工作，负责解析运行 JavaScript 脚本。和 GUI 渲染线程互斥，JS 运行耗时过长就会导致页面阻塞。

        * 3）事件触发线程:

           当事件符合触发条件被触发时，该线程会把对应的事件回调函数添加到任务队列的队尾，等待 JS 引擎处理。

        * 4）定时器触发线程:

          浏览器定时计数器并不是由 JS 引擎计数的，阻塞会导致计时不准确。开启定时器触发线程来计时并触发计时，计时完成后会被添加到任务队列中，等待 JS 引擎处理。

        * 5）http 请求线程:

          http 请求的时候会开启一条请求线程。请求完成有结果了之后，将请求的回调函数添加到任务队列中，等待 JS 引擎处理。
 + 进程和线程，进程里面一定有线程吗？
    - 什么是线程？什么是进程？为什么要有线程？有什么关系与区别？
    - 进程：

       * 程序执行时的一个实例
       * 每个进程都有独立的内存地址空间
       * 系统进行资源分配和调度的基本单位
       * 进程里的堆，是一个进程中最大的一块内存，被进程中的所有线程共享的，进程创建时分配，主要存放 new 创建的对象实例
       * 进程里的方法区，是用来存放进程中的代码片段的，是线程共享的
       * 在多线程 OS 中，进程不是一个可执行的实体，即一个进程至少创建一个线程去执行代码

      
    - 为什么要有线程？

       * 每个进程都有自己的地址空间，即进程空间。一个服务器通常需要接收大量并发请求，为每一个请求都创建一个进程系统开销大、请求响应效率低，因此操作系统引进线程。      

    -  线程：

       * 进程中的一个实体
       * 进程的一个执行路径
       * CPU 调度和分派的基本单位
       * 线程本身是不会独立存在
       * 当前线程 CPU 时间片用完后，会让出 CPU 等下次轮到自己时候在执行
       * 系统不会为线程分配内存，线程组之间只能共享所属进程的资源
       * 线程只拥有在运行中必不可少的资源(如程序计数器、栈)
       * 线程里的程序计数器就是为了记录该线程让出 CPU 时候的执行地址，待再次分配到时间片时候就可以从自己私有的计数器指定地址继续执行
       * 每个线程有自己的栈资源，用于存储该线程的局部变量和调用栈帧，其它线程无权访问
 

      
    - 关系：

      * 一个程序至少一个进程，一个进程至少一个线程，进程中的多个线程是共享进程的资源Java 中当我们启动 main 函数时候就启动了一个 JVM 的进程，而 main 函数所在线程就是这个进程中的一个线程，也叫做主线程一个进程中有多个线程，多个线程共享进程的堆和方法区资源，但是每个线程有自己的程序计数器，栈区域



    - 区别：

      * 本质：进程是操作系统资源分配的基本单位；线程是任务调度和执行的基本单位
      * 内存分配：系统在运行的时候会为每个进程分配不同的内存空间，建立数据表来维护代码段、堆栈段和数据段；除了 CPU 外，系统不会为线程分配内存，线程所使用的资源来自其所属进程的资源
      * 资源拥有：进程之间的资源是独立的，无法共享；同一进程的所有线程共享本进程的资源，如内存，CPU，IO 等开销：每个进程都有独立的代码和数据空间，程序之间的切换会有较大的开销；线程可以看做轻量级的进程，同一类线程共享代码和数据空间，每个线程都有自己独立的运行程序计数器和栈，线程之间切换的开销小
      * 通信：进程间 以IPC（管道，信号量，共享内存，消息队列，文件，套接字等）方式通信 ；同一个进程下，线程间可以共享全局变量、静态变量等数据进行通信，做到同步和互斥，以保证数据的一致性
      * 调度和切换：线程上下文切换比进程上下文切换快，代价小
      * 执行过程：每个进程都有一个程序执行的入口，顺序执行序列；线程不能够独立执行，必须依存在应用程序中，由程序的多线程控制机制控制
      * 健壮性：每个进程之间的资源是独立的，当一个进程崩溃时，不会影响其他进程；同一进程的线程共享此线程的资源，当一个线程发生崩溃时，此进程也会发生崩溃，稳定性差，容易出现共享与资源竞争产生的各种问题，如死锁等
      * 可维护性：线程的可维护性，代码也较难调试，bug 难排查

      * 进程与线程的选择：

      * 需要频繁创建销毁的优先使用线程。因为进程创建、销毁一个进程代价很大，需要不停的分配资源；线程频繁的调用只改变 CPU 的执行
      * 线程的切换速度快，需要大量计算，切换频繁时，用线程
      * 耗时的操作使用线程可提高应用程序的响应
      * 线程对 CPU 的使用效率更优，多机器分布的用进程，多核分布用线程
      * 需要跨机器移植，优先考虑用进程
      * 需要更稳定、安全时，优先考虑用进程
      * 需要速度时，优先考虑用线程
      * 并行性要求很高时，优先考虑用线程
 
 + 单核CPU只能运行一个进程吗?单核CPU只能运行一个线程吗?
     - 单核CPU执行多进程是通过资源的合理调度
     - 单核CPU是不能并行执行的，只能并发执行，单核只能运行一个线程，多核可将线程的并发转为并行。
     - 进程的最小调度单位是线程，你可以简单的把进程看做是一些线程的集合，一个进程最少有一个线程，也可能有很多线程。

     - 1.多核CPU同时可以执行多个线程，有几个核就能执行几个线程。
     - 2.这些线程分属不同进程的话就是执行了多个进程。
     - 3.这些线程分属同一个进程的话就是只执行了一个进程的不同线程。
     - 4.多核CPU和多个CPU运行机制相同也不同，单就运行多线程任务来讲原理是差不多的。

   
 + 异步和同步的区别
    - 同步：

      * 同步的思想是：所有的操作都做完，才返回给用户。这样用户在线等待的时间太长，给用户一种卡死了的感觉（就是系统迁移中，点击了迁移，界面就不动了，但是程序还在执行，卡死了的感觉）。这种情况下，用户不能关闭界面，如果关闭了，即迁移程序就中断了。

     - 异步：

      * 将用户请求放入消息队列，并反馈给用户，系统迁移程序已经启动，你可以关闭浏览器了。然后程序再慢慢地去写入数据库去。这就是异步。但是用户没有卡死的感觉，会告诉你，你的请求系统已经响应了。你可以关闭界面了。

     - 同步和异步本身是相对的
      * 同步就相当于是 当客户端发送请求给服务端，在等待服务端响应的请求时，客户端不做其他的事情。当服务端做完了才返回到客户端。这样的话客户端需要一直等待。用户使用起来会有不友好。
      * 异步就是，当客户端发送给服务端请求时，在等待服务端响应的时候，客户端可以做其他的事情，这样节约了时间，提高了效率。
      * 存在就有其道理 异步虽然好 但是有些问题是要用同步用来解决，比如有些东西我们需要的是拿到返回的数据在进行操作的。这些是异步所无法解决的
 + ajax里面的async异步原理  async的异步是独立的线程吗(重点)
   - 单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。如果前一个任务耗时很长，后一个任务就不得不一直等着。

   - 如果排队是因为计算量大，CPU忙不过来，倒也算了，但是很多时候CPU是闲着的，因为IO设备（输入输出设备）很慢（比如Ajax操作从网络读取数据），不得不等着结果出来，再往下执行。

   - JavaScript语言的设计者意识到，这时主线程完全可以不管IO设备，挂起处于等待中的任务，先运行排在后面的任务。等到IO设备返回了结果，再回过头，把挂起的任务继续执行下去。

   - 于是，所有任务可以分成两种，一种是同步任务（synchronous），另一种是异步任务（asynchronous）。同步任务指的是，在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务；异步任务指的是，不进入主线程、而进入"任务队列"（task queue）的任务，只有"任务队列"通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。

   - 具体来说，异步执行的运行机制如下。（同步执行也是如此，因为它可以被视为没有异步任务的异步执行。）
     * （1）所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）。

     * （2）主线程之外，还存在一个"任务队列"（task queue）。只要异步任务有了运行结果，就在"任务队列"之中放置一个事件。

     * （3）一旦"执行栈"中的所有同步任务执行完毕，系统就会读取"任务队列"，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。
 
     * （4）主线程不断重复上面的第三步。
     
     只要主线程空了，就会去读取"任务队列"，这就是JavaScript的运行机制。这个过程会不断重复。

     ![](media/单线程同步异步.jpg)
 + css的定位   绝对定位相对于谁？（主要问题：绝对定位相对于谁）
    -  relative：定位是相对于自身位置定位（设置偏移量的时候，会相对于自身所在的位置偏移）。设置了relative的元素仍然处在文档流中，元素的宽高不变，设置偏移量也不会影响其他元素的位置。最外层容器设置为relative定位，在没有设置宽度的情况下，宽度是整个浏览器的宽度。
    - absolute：定位是相对于离元素最近的设置了绝对或相对定位的父元素决定的（另一种说法：相对于第一个不是static的父元素定位），如果没有父元素设置绝对或相对定位，则元素相对于根元素即html元素定位。

 + 虚拟-DOM 讲讲   和真实DOM的联系点
   - 什么是Virtual DOM？
   - 所谓virtual，指的是对真实DOM的一种模拟。相对于直接操作真实的DOM结构，我们构建一棵虚拟的树，将各种数据和操作直接应用在这棵虚拟的树上，然后再将对虚拟的树的修改应用到真实的DOM结构上。
这样有以下好处：

   - 可能会减少DOM操作次数，带来性能上的提升，即使我们频繁操作虚拟DOM，我们只需要一定时刻一次性同步修改到真实DOM上即 可
   - 真实的HTML节点有两百多个属性和方法，使用虚拟节点，能在数据结构上节省内存。
   - 虚拟DOM不依赖浏览器环境，能在node环境实现，可以使用虚拟DOM生成html字符串，实现SSR

 + vue的钩子函数一定需要吗？ 一定要有，但是钩子函数可以变化，在不同的时机切入对应的代码即为钩子函数的作用。
      - 当下面三个条件存在的时候，生命周期就需要存在

        * 业务代码是被调度执行，且调度器和业务逻辑是交叉执行。
        * 某些状态是调度器掌控，业务代码无法知晓时机。
        * 对状态变化的反应要超出调度器自身能力。
      - 拿前端UI框架举例：

        * 开发者的组件是声明式的，组件被创建、被挂载和被消费都不是开发者主动掌握的，而是框架调度的。
        * 组件从unMount状态过渡到mount状态，或者从mount状态变成unMount时，开发者并不知晓，这个状态变化由调度器掌控。
        * 框架自身的能力是 View = f(state) ，但是开发者有副作用的需求，比如拉取外部数据、设置定时器等等，这些超出了框架自身能力。
        * 为此框架必须开一些口子给开发者，也就是所谓的生命周期hooks。
        * @顾轶灵 说的“生命周期，不就是用来提供 aop 的 hook 么”其实点出了本质，当代码运行时不由你掌控，而你又想在对应时机切入对应的代码时，生命周期就不得不存在了。
 + 怎么和真实的DOM树上建立联系
   key这个属性，可以把 页面上的 DOM节点 和 虚拟DOM中的对象，做一层关联关系；
 + vue2.0 和 vue3.0变化很大，为什么能在很短的时间内适应
 + 看看React的书，渲染过程。
 + 关于后台知识，说说

面试语速   理清思路回答
